- 토큰 : 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

- 디렉터리 명 : 소문자/하이픈으로 구성 (대문자/언더바 사용 지양)


- 구름ide에서 도메인 만들기
    
    대시보드에서 컨테이너 더보기 -> URL/Port에서 도메인을 입력하고 해당 포트번호를 입력 후 추가하면 됨.


- 9090 포트 : Admin


- require() 메서드

    node.js에서 외부 모듈을 가져오는 메서드.
    node가 local object에 추가한 메서드이다.
    import가 사용됨 (<-> export)
    
    인자 : 추가할 모듈의 파일 경로
    사용법 : const foo = require('경로');
    
    
- listen() 메서드

    서버를 띄우는 메서드.
    
    listen(포트번호, 콜백함수);
    * 콜백함수 : 코드를 통해 명시적으로 호출하는 함수가 아니라,
      함수를 등록해두고 어떤 조건이 충족되었을 때 호출되는 함수
      여기서는 서버가 띄워지면 실행할 동작을 지정하는 용도.
      
      
- node : 자바스크립트 파일을 v8 엔진으로 컴파일하라는 명령어
         (v8 : 자바스크립트 컴파일러)
         

- package.json ?


- get() 메서드

    일단은 이걸 쓴다.. 경로를 만드는 메서드 ?
    브라우저에서 지정한 경로로 요청이 들어오면 콜백함수를 실행하는 메서드
    일단 루트 경로는 무조건 만들어두기
    브라우저의 요청과 브라우저로의 응답을 위해 콜백함수의 매개변수로는
    요청(req)과 응답(res)의 두 가지를 사용한다.
    
    get("경로", 콜백함수(req, res));
    
    res.send() ???
    
    
- 수정을 하고 나면 서버를 껐다 켜야 변경사항이 적용된다.
  서버 끄는 법 : Ctrl + C (실행중인 프로세스 종료)
  
  
- http 대신 express를 사용해야 하는 이유

    1) 코드가 깔끔해진다 : http에서는 코드가 지저분해지지만 express를 사용하면 간결해짐
    2) http에서는 charset을 설정해주지 않으면 한글이 깨질 수도 있다
    
    +) http에서는 createServer 밑에 콜백함수에 모든 세팅을 해야 하지만
       express를 사용하면 그 자체를 객체로 만들어 사용할 수 있어 편리한듯 (뇌피셜)
       
       
- req, res

    req : 요청. req.url을 하면 도메인 뒤 '/'부터의 url이 반환된다
    res : 응답. send(), ...
    
    그냥 매개변수인 줄 알았는데 이거 자체로 정의된 게 있는건감
    잘 모르게다
    
    
- 서버에 html 띄우는 법 : res.send() 인자에 html 태그를 넣기.
  이 때 html 태그를 백틱(``)으로 묶어주어야 한다.
  
  
- <input type="text"> 태그 속성 : placeholder="" -> 텍스트 입력칸에 힌트메시지


- button 태그 : <button></button>


- indent 단축키
    
    indent : tab 키
    back indent: shift + tab 키
    

- set() 메서드

    1) views 세팅 : "views", view를 관리할 파일이 저장될 폴더를 지정
    2) view 엔진 세팅 : "view engine", 엔진 이름 지정 (ex. ejs)
    
    
- res.render() : 기본 설정된 view 폴더 하위부터 해당 파일까지 경로 작성
                 -> 해당 파일을 엔진이 해석. (컴파일 ?)
                 
                 
- view 분리하기

    1) views 세팅 : 같은 경로에 views 폴더 만들어 관리
    2) view engine 세팅
    3) ejs(view 엔진) 설치 (npm 이용)
    4) view 관리 폴더 하위에 관리할 ejs파일 생성 후 내용 삽입
    5) get()의 콜백함수에 res.render("파일이름") 형태로 사용
    
    
- "use strict"; : 모든 js파일 최상단에 작성, ECMAScript 준수함을 명시


- use() 메서드 : '미들 웨어'를 등록해주는 메서드. 


- 라우팅 분리하기

    1) 라우팅 세팅 : 같은 경로에 routes 폴더 만들어 관리
    2) routes 관리 폴더 하위에 관리할 js파일 생성 후 내용 삽입
       -> express() 대신 express.Router()를 실행시켜 객체화
    3) 라우팅 분리 파일을 export하기 : module.exports = router;
    4) require("해당 파일 경로")를 이용해 라우팅 관리 파일을 불러옴
    5) use() 메서드를 이용해서 라우팅 관리 파일로 넘어감
    
    
- MVC 패턴 (모델-뷰-컨트롤러 패턴)

    하나의 애플리케이션의 구성 요소를 세가지로 구분한 디자인패턴
    "어떻게 나눌 것인가"에 대한 해답 중 하나라고 볼 수 있음
    
    1) Model : 애플리케이션의 정보, 데이터
    2) View : UI 요소
    3) Controller : 사용자가 일으키는 이벤트를 처리하는 부분
    
    사용자가 컨트롤러를 조작하면 컨트롤러가 모델을 통해 데이터를
    가져오고 이를 바탕으로 뷰를 제어해 시각적 표현으로 전달하는 구조
    
    역할을 분리해서 서로 각자의 역할에 집중할 수 있도록 구조화시키면
    유지보수, 확장성, 유연성이 증가하며 중복의 문제가 줄어든다.
    
    
- node.js에서의 MVC

    나누기 애매한 부분이 있는 것 같당
    
    router.get("/login", (req, res) => {
        res.render("home/login");
    });
    
    에서
    
    router.get() 자체는 사용자의 요청을 연결시켜주는 것에 불과하고
    그 인자인 콜백함수에 있는 res.render("home/login"); 부분이
    실제 컨트롤러라고 할 수 있다
    
    
- controller 분리하기

    1) 라우터에서 컨트롤러가 쓰이므로 같은 경로에 컨트롤러 js파일 생성
    2) router.get() 에서 사용하는 컨트롤러인 콜백함수를 파일로 옮김
    3) 콜백함수를 정의 후 객체로 export
    4) 라우터 파일에서 컨트롤러 파일을 require()로 import
    5) 콜백함수 인자에 import한 콜백함수를 대입
    
    
- listen() 분리하기

    1) 메인 파일과 같은 경로에 bin 디렉터리를 생성
    2) bin 하위에 서버를 가동시키기 위한 js 파일을 생성
    3) app를 사용하기 위해 메인 파일에서 export
    4) 해당 파일에서 app를 import한 후 listen()부분 복붙
    
    
- package.json

    1. package.json : 패키지에 대한 정보를 입력하는 파일.
    
        1) 설치 : npm init (-y : 설정 기본값으로 설치)
        2) 용도 : npm에 업로드될 때 해당 파일 참고하여 정보가 등록됨
        3) 사용 : 알잘딱깔센
        
        
    2. package-lock.json : 모듈의 버전을 더 정확하게 명시하는 파일.
    
        package.json 파일에는 의존성 모듈들의 버전이 범위로 표현되어
        있지만 package-lock.json 파일에는 정확한 버전이 명시되어있음
        (모듈을 위한 모듈의 버전들까지 전부 다.)
        
        * 버전 앞 기호 (버전 표기법 : Main.Minor.Patch)
            ^ : Main버전은 다르면 안되지만 Minor 버전까지는 달라도 됨
            ~ : Patch 버전 말고는 다르면 안됨
    
    
    3. node_modules 디렉터리 : 설치한 모듈들이 저장되는 디렉터리.
    
        node_modules 디렉터리가 없으면 프로젝트를 실행할 수 없지만
        npm install 명령어를 입력하면 package.json 파일의
        dependencies 항목에 적혀있는 모듈들을 알아서 설치하기 때문에
        언제든지 다시 설치할 수 있다. (package.json은 없어선 안됨)
    
        
- npm : Node Package Manager

    자바스크립트 언어를 위한 패키지 관리자로 node.js의 기본 패키지 관리자.
    node.js에서 사용하는 모듈들을 패키지로 만들어 npm에 업로드하고 관리함.
    npm 웹사이트를 통해 사용 가능한 패키지들을 찾아보고 검색할 수 있음
    온라인 데이터베이스에 공개/개인 패키지들이 저장/관리되고 있다.
    
    -> npm으로 패키지/모듈 설치
    
    
- bin 디렉터리 : 하위에 실행파일들이 담기는 디렉터리


- JSON

    JavaScript Object Notation(JSON)
    쉽게 데이터를 교환/저장하기 위해 만들어진
    텍스트 기반 데이터 교환 표준.
    
    1) 자바스크립트의 객체표기법에서 리터럴과 프로퍼티 표현만 가져옴
    2) 주석을 사용할 수 없다..
    
    
- github에 업로드하기

    1) repository 생성
    2) git init: git 사용
    3) README.md / .gitignore 파일 생성 (.gitignore: 업로드 제외 파일 목록)
    4) 커밋/업로드 진행
        git add: 스테이지 영역에 올림 (git add .)
        git commit: 커밋 (.git에 변경 사항들 저장) (git commit -m "메시지")
        git remote: 관리중인 워킹 디렉터리를 repository에 연결
            -v : remote 상태 확인
            add origin 주소 : remote 연결 (origin은 이름)
        git push: github에 업로드 (git push origin master)
        
    업로드 할 때, node_modules 폴더는 업로드하면 안됨.
    -> 용량이 크고, 어차피 npm install로 언제든지 다시 만들 수 있음
    
    
- github에 업로드해둔 프로젝트 다운로드하기

    1) repository 주소 복사하기
    2) git clone 주소 -> 다운로드 완료.
    3) npm install
    
    
- github에 업로드된 프로젝트로 업데이트하기

    git pull origin master
    -> origin 저장소의 master 브랜치에 해당하는 내용 가져옴
    
    
- .gitignore : 파일명 앞에 ** 붙이면 하위폴더까지 싹 뒤져서 제외. (recursive)


- 폴더 구조 최적화

    app 폴더 안에 필요한 파일들을 넣어서 정리한 후
    하위 디렉터리로 src / bin 을 생성해서
    src 디렉터리에는 소스 코드들을 넣어서 관리
    bin 디렉터리에는 실행 코드들을 넣어서 관리
    
    
- 13. public 폴더 연결

    미들웨어 / app.use() / 프론트단 js파일 생성 후 ejs 파일에 연결
    ??????
    
    
- git push

    git push remote branch
    remote값과 branch값을 지정하지 않으면 기본으로 설정되어 있는 값으로 실행
    -> git push origin master 자동 실행
    
    
- nodemon

    설치 : npm install nodemon -g (-g : 전역)
    사용 : nodemon 실행파일경로 -> nodemon으로 서버 가동
    기능 : nodemon으로 서버를 가동하면, 소스 코드를 수정해 저장할 때마다
          알아서 서버를 재가동함. 수정할 때마다 일일이 껐다 켤 필요 없음
    
        
- DOM

    개념 : Document Object Model -> HTML에 존재하는 데이터를 js로 가져와
                                제어할 수 있게 해주는 인터페이스
    사용 : document 객체 사용 -> document.제어함수() 식으로 사용
    
    * input 태그 값 가져오기 : 태그.value 로 접근
    
    
- ejs 사용 시 script를 연결하는 방식

    defer / async  <script src="" defer>
    -> 다른 강의 참고
  
  
- fetch() : 데이터를 서버로 보내기

    fetch("경로", 보낼 데이터(객체));
        ex) fetch("/login", {
              method: ,
              headers: ,
              body: 
            })
        
    해당 데이터를 서버가 받기 위해서는 필요한 형식의 API가 마련되어있어야 함
    


- API : Application Programming Interface

    개념 : 서버와 클라이언트가 통신하기 위한 규약
    응용프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는
    기능을 제어할 수 있게 만든 인터페이스이다.
    -> 파일제어, 창제어, 화상처리, 문자제어 등을 위한 인터페이스 주로 제공
    
    
- Restful API

    1) Rest의 정의 : 분산 시스템 설계를 위한 아키텍쳐(구성) 스타일
                    -> "사이트 구성 원리."
                    (REpresentational/State/Transfer : 표현/상태/전송)
                    -> 자원의 표현을 가지고 상태를 전달한다.
                    
    2) Restful API : 사이트 구성 원리를 따르는 API.
    
    
- 파싱 ?


- body-parser 모듈

    fetch로 데이터를 서버로 넘길 때,
    데이터의 body에 접근하기 위해 설치하는 모듈.
    
    설치 : npm i body-parser -s
    (-s : package.json 파일 의존성 목록에 해당 모듈을 명시)
    
    
- 데이터를 수신할 API 만들기

    0) body-parser 모듈 설치
    1) 라우팅 ctrl에서 해당 fetch에 대한 응답 함수(API?) 만들기
    2) 라우팅 index에서 해당 함수 import해서 post 메서드로 실행
    3) app에서 미들웨어 작성 : body-parser로 json 데이터 파싱 / 한글인코딩
    
    
- 로그인 인증하기

    1) include() 메서드
    2) then() 메서드
    3) location 메서드
    4) catch() 메서드
    5) console.error() / new Error() 메서드
    
    
- 클래스와 인스턴스
        
    인스턴스를 생성하지 않고 클래스 자체에서 내부 요소에 접근하고자 할 때는
    해당 요소를 정적으로 선언해주면 된다. (앞에 static을 붙이면 됨)
        
    -> 원래는 static으로 선언한 요소를 외부에서 접근할 수 있으면 안됨.
    따라서 접근할 수 없도록 설정해주어햐 함 (은닉 / private 선언)
        
    -> 요소 앞에 #을 붙임  ex) static #users = {}
        
    -> private 요소를 반환해주는 메서드가 필요
        
        
- 20. Model 만들기

    지금은 객체를 만들어 데이터를 저장했지만 나중에는 데이터베이스를 연결해서 사용함
    데이터는 외부에서 접근해서는 안되기 때문에 private으로 선언하고
    해당 객체를 읽을 수 있게 반환하는 메서드를 만들어서 데이터에 접근
    
    1) 배열.reduce() : 뭔말인지 모르겟덩
    2) 데이터베이스에 존재하는 여러 필드값 중 필요한 필드값만 가져올 수 있는 기능을
       get 메서드(데이터 반환하는 메서드)에 포함시킴
       
       
- 21. 로그인 인증 기능 User 클래스로 분리하기 (모델 완성)

    일단 기본적으로 자바스크립트에 대한 기본기가 부족한듯
    자바스크립트 기본기 / DOM / OOP에 대해 더 

    1) object.keys() : ?
    
    
- 22. 프론트 꾸미기

    codepen에서 오픈소스 사용
    css파일을 public 폴더에 하위폴더를 만들어서 저장하고 html/css/js 파일을 연결
    
    
- 23. 회원가입 화면 만들기

    HTML에서 공백은 하이픈(-)으로 표기 (컨벤션)
    라우터 단에서 렌더링
    
    
- 24. 회원가입 요청 구현

    1) html form 태그 : form 태그 안에 있는 button 태그를 누르면 summit 해주는 기능
                       따라서, 누르고 나면 페이지가 새로고침됨

    
        
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    